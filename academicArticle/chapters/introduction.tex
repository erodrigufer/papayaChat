\section{Introduction}
When using any of the most popular modern web development frameworks the inherent system architecture supporting multiple concurrent client connections is often concealed from the developer. Moreover, the system-level design choices to handle concurrent connections tend to be immutable, so that, for instance, a framework based on an event-driven architecture, like Node.js, cannot be modified or configured to work in a multi-threaded or multi-procedural way. It could be argued that modern web development ecosystems have entirely renounced providing the user with the full spectrum of system-level primitives that can enable concurrency, in favour of abstracting the complexity of concurrent systems away from the framework's APIs and making portability invisible to the developer.

\cite{2005Threads} \cite{2013ContextSwitching}\cite{2003Events}

Another aspect that characterizes some of these frameworks, is that the developer ends up having many different library or packet dependencies from a diverse range of sources, which are sometimes fundamental to enable basic functionality or enhance the capabilities of the framework. With an increasing number of dependencies numerous issues can arise, e.g. mutual incompatibilities between different package versions, supply chain attacks, a cumbersome management of patches for vulnerabilities and difficulties recreating the same behaviour of an application between the development and the production environments \cite{2012PoulHenning}. 

The goal of this work is to develop a stand-alone, almost dependency-free, command-line interface chat service independent of current backend frameworks. In order to explore the challenges and advantages of different system-level networking architectures. There is an unexplored technological gap, because current web frameworks do not offer the ability to implement backend services in a multi-procedural and dependency-free way. 

The chat service backend will be entirely developed using C, due to the fact that this language provides all possible system calls (syscalls) capable of directly interacting with kernel concurrency primitives in Unix systems. Moreover, the secondary goal of requiring the least amount of dependencies as possible for this application fits well with a development environment consisting of only GCC as a compiler and the C standard library, which are both ubiquitous on Unix systems nowadays. 

From a more philosophical point of view, the choice to develop an instant messaging (IM) application capable of being self-hosted by the user is a very deliberate decision. Although, this is not the main goal of this work, it is motivated by the fact that there are no good mainstream alternatives for messaging services. WhatsApp fails miserably as a suitable option since it coerces users to remain on its platform to indiscriminately harvest metadata as a mean to increase ad revenue \cite{Kumar2021}. Signal seems to be a viable alternative at first glance. But it is actually as vulnerable as WhatsApp to fail catastrophically regarding its availability, since its backend is a centralized and closed platform \cite{Hodgson2020}. Also, at least until 2016, it allowed some user metadata to traverse through Google cloud services \cite{Edge2016} and has already handed user metadata to law enforcement authorities in the past \cite{Kaufman2016}. Furthermore, all major social media platforms offer some kind of IM capabilities, but at the cost of allowing that the users' data be thoroughly harvested for some kind of value generation \cite{socialmedia2017}. To some extent, more than a coding exercise, the fully functional chat app that came out of this work (which can be found in this GitHub repository \cite{Rodriguez2022}) is a way of regaining control over the most sensitive data and metadata produced from our daily communication needs, while simultaneously shielding it against commercialization.