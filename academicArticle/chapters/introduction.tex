\section{Introduction}
When using any of the most popular modern web development frameworks the inherent system architecture supporting multiple concurrent client connections is often concealed from the developer. Moreover, the system-level design choices to handle concurrent connections tend to be immutable, so that, for instance, a framework based on an event-driven architecture, like Node.js, cannot be modified or configured to work in a multi-threaded or multi-procedural way. It could be argued that modern web development ecosystems have entirely renounced providing the user with the full spectrum of system-level primitives that can enable concurrency, in favor of abstracting the complexity of concurrent systems away from the framework's APIs and making portability invisible to the developer.

Another aspect that characterizes some of these frameworks, is that the developer ends up having many different library or packet dependencies from a diverse range of sources, which are sometimes fundamental to enable basic functionality or enhance the capabilities of the framework. With an increasing number of dependencies numerous issues can arise, e.g. mutual incompatibilities between different package versions, supply chain attacks, a cumbersome management of patches for vulnerabilities and difficulties recreating the same behavior of an application between the development and production environments \cite{2012PoulHenning}. 

In the early days of web development, some of the literature comparing different concurrency paradigms favored threads over an event-driven architecture, primarily due to the better readability and maintainability that threads allegedly provide \cite{2003Events}\cite{2005Threads}. While at the same time acknowledging without experimental evidence that threads can have a higher CPU usage overhead due to context-switching \cite{2003Events}. Nonetheless, both \cite{2003Events} and \cite{2005Threads} expected that future improvements in compiler integration of threads and the development of frameworks that make use of '\textit{cooperative threading}' with user-space context-switching and small dynamic stack sizes would improve the performance of multi-threaded systems.

Eventually, multi-core platforms became ubiquitous and many languages like Go, Erlang and Elixir popularized cooperative threading as a way of getting more performance in concurrent web applications through, among other methods, parallelization and context-switching in user-space. \cite{2013ContextSwitching} presents an actual implementation of primitives for the LLVM compiler which support context-switching for coroutines and lightweight threads in a language-agnostic way. \cite{2013ContextSwitching} experimentally evaluates the performance of different 'cooperative threading' implementations with various context-switching benchmarks, the compiler-integrated architecture proposed in the paper outperforms other more popular alternatives as Go, Haskell and Erlang. 

Many sources claim that kernel-space context-switching like with processes and threads, should most of the times represent a very noticeable performance penalty in comparison to other concurrency approaches centered around user-space context-switching, like cooperative threads i.e. non-preemptively scheduled threads, without providing any experimental confirmation for those claims \cite{2003Events}\cite{2005Threads}\cite{Cox-Buday2017}\cite{Kerrisk2010}. Meanwhile, other sources that present experimental data, do not work with benchmarks directly related to concurrency in the context of web applications \cite{2013ContextSwitching}. 

The motivation of this paper is two-fold, on the one hand it strives to experimentally compare the CPU usage of the same web application 

The goal of this work is to develop a stand-alone, almost dependency-free, command-line interface chat service independent of current backend frameworks. In order to explore the challenges and advantages of different system-level networking architectures. There is an unexplored technological gap, because current web frameworks do not offer the ability to implement backend services in a multi-procedural and dependency-free way. 

The chat service backend will be entirely developed using C, due to the fact that this language provides all possible system calls (syscalls) capable of directly interacting with kernel concurrency primitives in Unix systems. Moreover, the secondary goal of requiring the least amount of dependencies as possible for this application fits well with a development environment consisting of only GCC as a compiler and the C standard library, which are both ubiquitous on Unix systems nowadays. 

From a more philosophical point of view, the choice to develop an instant messaging (IM) application capable of being self-hosted by the user is a very deliberate decision. Although, this is not the main goal of this work, it is motivated by the fact that there are no good mainstream alternatives for messaging services. WhatsApp fails miserably as a suitable option since it coerces users to remain on its platform to indiscriminately harvest metadata as a mean to increase ad revenue \cite{Kumar2021}. Signal seems to be a viable alternative at first glance. But it is actually as vulnerable as WhatsApp to fail catastrophically regarding its availability, since its backend is a centralized and closed platform \cite{Hodgson2020}. Also, at least until 2016, it allowed some user metadata to traverse through Google cloud services \cite{Edge2016} and has already handed user metadata to law enforcement authorities in the past \cite{Kaufman2016}. Furthermore, all major social media platforms offer some kind of IM capabilities, but at the cost of allowing that the users' data be thoroughly harvested for some kind of value generation \cite{socialmedia2017}. To some extent, more than a coding exercise, the fully functional chat app that came out of this work (which can be found in this GitHub repository \cite{Rodriguez2022}) is a way of regaining control over the most sensitive data and metadata produced from our daily communication needs, while simultaneously shielding it against commercialization.