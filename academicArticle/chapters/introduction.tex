\section{Introduction}
When using any of the most popular modern web development frameworks the inherent system architecture supporting multiple concurrent client connections is often concealed from the developer. Moreover, the system-level design choices to handle concurrent connections tend to be immutable, so that, for instance, a framework based on an event-driven architecture, like Node.js, cannot be modified or configured to work in a multi-threaded or multi-procedural way. It could be argued that modern web development ecosystems have entirely renounced providing the user with the full spectrum of system-level primitives that can enable concurrency, in favor of abstracting the complexity of concurrent systems away from the framework's APIs and making portability invisible to the developer.

Another aspect that characterizes some of these frameworks is that the developer ends up having many different dependencies from a diverse range of sources, which are sometimes fundamental to enable basic functionality or enhance the capabilities of the framework. With an increasing number of dependencies numerous issues can arise, e.g. mutual incompatibilities between different package versions, supply chain attacks, a cumbersome management of patches for vulnerabilities and difficulties recreating the same behavior of an application between the development and production environments \cite{2012PoulHenning}. 

In the early days of web development, some of the literature comparing different concurrency paradigms favored threads over an event-driven architecture, primarily due to the better readability and maintainability that threads allegedly provide \cite{2003Events}\cite{2005Threads}. While at the same time acknowledging without experimental evidence that threads can have a higher CPU usage overhead due to context-switching \cite{2003Events}. Nonetheless, both \cite{2003Events} and \cite{2005Threads} expected that future improvements in compiler integration of threads and the development of frameworks that make use of '\textit{cooperative threading}', i.e. user-space context-switching and small dynamic stack sizes, would improve the performance of multi-threaded applications.

Eventually, multi-core platforms became ubiquitous and many languages like Go, Erlang and Elixir popularized cooperative threading as a way of getting more performance in concurrent web applications through, among other methods, parallelization and context-switching in user-space. Furthermore, there have been advances in implementing compiler integration of cooperative threading \cite{2013ContextSwitching}\cite{2008Pekka}. An actual implementation of primitives for the LLVM compiler which support user-space context-switching for coroutines and lightweight threads in a language-agnostic way is presented by Dolan et al. \cite{2013ContextSwitching}. The paper experimentally evaluates the performance of different cooperative threading implementations with various context-switching benchmarks. The compiler-integrated architecture proposed in the paper outperforms Go, Haskell, Erlang and POSIX-threads in various metrics. 

Many sources claim that kernel-space context-switching like with processes and threads, should most of the times represent a very noticeable performance penalty in comparison to other concurrency approaches centered around user-space context-switching, like cooperative threads i.e. non-preemptively scheduled threads, without providing any experimental confirmation for those claims \cite{2003Events}\cite{2005Threads}\cite{Cox-Buday2017}\cite{Kerrisk2010}. Meanwhile, other sources that present experimental data, do not work with benchmarks directly related to concurrency in the context of web applications \cite{2013ContextSwitching}\cite{2008Pekka}. 

The motivation of this paper is two-fold, on the one hand it primarily strives to gather experimental data to test the assumption that multi-process concurrent web applications, due to their mostly kernel-centered context-switching, should be outperformed in terms of CPU usage by applications with coroutine-based context-switching taking place in user-space. For that matter, the CPU usage of the same concurrent web application will be compared between an implementation in C and an implementation in Go.

The secondary goal of this work is to develop a stand-alone, almost dependency-free, command-line interface chat service independent of current backend frameworks. In order to put into practice the concurrency handling primitives tested and to explore the challenges and advantages of different system-level networking architectures.

The chat service backend will be entirely developed using C, due to the fact that this language provides all possible system calls (syscalls) capable of directly interacting with kernel concurrency primitives in Unix systems. Moreover, the requirement of using the least amount of dependencies for this application fits well with a development environment consisting of only GCC as a compiler and the C standard library, which are both ubiquitous on modern Unix systems. 

The choice to develop an instant messaging (IM) application capable of being self-hosted by the user is a very deliberate decision. Although, this is not the main goal of this work, it is motivated by the fact that there are no good mainstream alternatives for messaging services. WhatsApp fails miserably as a suitable option since it coerces users to remain on its platform to indiscriminately harvest metadata as a mean to increase ad revenue \cite{Kumar2021}. Signal seems to be a viable alternative at first glance. But it is actually as vulnerable as WhatsApp to fail catastrophically regarding its availability, since its backend is a centralized and closed platform \cite{Hodgson2020}. Furthermore, all major social media platforms offer some kind of IM capabilities, but at the cost of allowing that the users' data be thoroughly harvested for some kind of value generation \cite{socialmedia2017}. To some extent, more than a coding exercise, the fully functional chat app that came out of this work (which can be found in this open-source GitHub repository \cite{Rodriguez2022}) is a way of regaining control over the most sensitive data and metadata produced by our daily communication needs.