\section{Conclusion}
Creating a backend service from the ground up gives the developer the freedom of choosing between a thread-oriented, process-oriented, pre-emptively or non-pre-emptively scheduled architecture. For some applications that are expected to work at almost the full capacity of the CPU usage of a machine, it makes sense to consider porting their code to a multi-process implementation in C, instead of developing in a platform with a more modern and complex concurrency paradigm, like Go. Since, the results of our measurements show a more stable CPU utilization in the multi-procedural implementation in C, with a much lower coefficient of variation at high loads.  Nonetheless, it must be acknowledged that the development productivity while programming low-level network concurrency, as in C, is not as high as compared to a high-level framework with mature networking libraries.

Furthermore, at all levels of concurrent network connections tested, the C implementation with context-switching in kernel-space, instead of in user-space as with the Go application, had a significantly lower percentage of CPU utilization. The non-preemptively scheduled Go application shows an almost linear increase in the CPU utilization proportional to an increase in the number of concurrent connections, while the C program drastically reduces the rate of CPU usage increase after 16 concurrent client connections. In a comparison based on programs similar to real-life deployed network applications, like in this case, the CPU usage is influenced not only by the context-switches, but also by inherent traits of the platform running the application. In this case, the actual performance gains attributable to user-space context-switching dwindle compared to the overhead of the Go runtime and GC.

The dependency restriction of only using the C standard library and compiling with GCC did not guarantee an entirely bug-free portability between Unix platforms. Therefore, even when reducing dependencies to a bare minimum, it is an illusion to think that fully portable code can easily be generated, so that to some extent the appeal and reasoning behind OS-virtualization (container management systems) can be better grasped.

Finally, the software developed in this project \cite{Rodriguez2022}, distributed through a public repository with a AGPL license (GNU Affero General Public License), delivers a functional command-line chat application that gives the user the possibility to self-host its chat service and regain full control over the management of its instant messaging data and metadata. Furthermore, it allows its users to avoid vendor lock-in effects and the single points of failure of an IM application with a centralized architecture like Signal and WhatsApp, since its minimal amount of dependencies facilitate a prompt native deployment in any Unix system.