\section{Conclusion}
Creating a backend service from the ground up gives the developer the freedom of choosing between a thread-oriented, process-oriented, preemptively or non-preemptively scheduled architecture. At all levels of concurrent network connections tested, the C implementation with context-switching in kernel-space, instead of in user-space as with the Go application, had a significantly lower percentage of CPU utilization. The non-preemptively scheduled Go application shows an almost linear increase in the CPU utilization proportional to the number of active concurrent connections. The performance gap between the two implementations is at its maximum by 64 active concurrent connections. In a comparison based on programs similar to real-life deployed network applications, like in this case, the CPU usage is influenced not only by the context-switches, but also by inherent traits of the platform running the application. In this case, the actual performance gains attributable to user-space context-switching dwindle compared to the overhead of the Go runtime and GC.

The results of the calculation of the coefficient of variation show that the multi-process implementation in C has a more unstable CPU utilization (higher $C_v$) as the Go implementation at high loads. This insight is of interest for application that have to be dimensioned to withstand and work at very high loads, since an application with a smaller Cv will react more predictably and securely close to the maximum possible CPU usage of a platform by not putting an even bigger burden on the server with CPU load spikes.

In the future, further experiments can try to reduce the interference of system daemons during the measurements by selectively turning them off.

The dependency restriction of only using the C standard library and compiling with GCC did not guarantee an entirely bug-free portability between Unix platforms. Therefore, even when reducing dependencies to a bare minimum, it is an illusion to think that fully portable code can easily be generated, so that to some extent the appeal and reasoning behind OS-virtualization (container management systems) can be better grasped.

Finally, the software developed in this project \cite{Rodriguez2022}, distributed through a public repository with a AGPL license (GNU Affero General Public License), delivers a functional command-line chat application that gives the user the possibility to self-host its chat service and regain full control over the management of its instant messaging data and metadata. Furthermore, it allows its users to avoid vendor lock-in effects and the single points of failure of an IM application with a centralized architecture like Signal and WhatsApp, since its minimal amount of dependencies facilitate a prompt native deployment in any Unix system.