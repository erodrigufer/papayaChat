\section{Conclusion}
Creating a backend service from the ground up gives the developer the freedom of choosing between a thread-oriented, process-oriented, pre-emptively or non-pre-emptively scheduled architecture. For some applications that are expected to work at almost the full capacity of the CPU usage of a machine, it makes sense to consider porting there code to a multi-process implementation in C, instead of developing in a platform with a more modern and complex concurrency paradigm, like Go. Since, the results of our measurements show a more stable CPU utilization in the multi-procedural implementation in C, with a much lower coefficient of variation at high loads. 

Furthermore, overall at all levels of concurrent network connections tested, the C implementation with context-switching in kernel-space, instead of in user-space as with the Go application, had a significantly lower percentage of CPU utilization. %% TODO: continue here

 Nonetheless, it must be acknowledged that the development productivity, particularly because of the debugging of syscalls with strace, is not high compared to a high-level framework with mature networking libraries.

Furthermore, although the software was exclusively tested on Debian-based platforms, the dependency restriction of only using the C standard library and compiling with GCC did not guarantee an entirely bug-free portability between Unix platforms. A different default initialization of the parameters of some syscalls by the compiler generated difficult to find sources of faulty and unequal behaviour between platforms. Therefore, even when reducing dependencies to a bare minimum, it is an illusion to think that fully portable code can easily be generated, so that to some extent the appeal and reasoning behind OS-virtualization (container management systems) can be better grasped.


FInally, the software developed in this project \cite{Rodriguez2022}, distributed through a public repository with a AGPL license (GNU Affero General Public License), delivers a functional command-line chat application that gives the user the possibility to self-host its chat service and regain full control over the management of its instant messaging data and metadata. Furthermore, it allows its users to avoid vendor lock-in effects and the single points of failure of an IM application with a centralized architecture like Signal and WhatsApp, since its minimal amount of dependencies facilitate a prompt native deployment in any Unix system.