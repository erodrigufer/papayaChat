\begin{abstract}
Most of the popular modern web development frameworks, like Node.js and Go, handle the creation and management of a backend service in a mostly abstracted high-level way that does not allow a developer much freedom to modify the inherent system architecture of the server. Such an inflexible and abstracted, often plug-and-play, server implementation helps to facilitate web development by concealing the system-level design choices from the end user. Modern web frameworks mostly try to handle concurrent client connections in user-space under the premise that handling concurrency in kernel-space is too costly. The problem of blindly relying on a web framework without understanding its internal architecture is that it might not be the most efficient choice for a web application that has to deal with multiple concurrent connections. This paper provides an experimental comparison of the CPU utilization efficiency of two completely different concurrency-handling paradigms: a multi-process implementation in C and a \textit{goroutine}-based non-preemptively scheduled web service in Go. The aim is to see if there is a performance penalty for handling concurrency in web applications primarily in kernel-space, rather than in user-space, as most modern web frameworks tend to do nowadays.
\end{abstract}
