\section{Experiments}
To evaluate the performance of a concurrency paradigm based upon context-switching in user-space and another one based upon context-switching in kernel-space, the same very rudimentary IM application was developed in both C and Go. The C program handles concurrent client network connections by spawning a new process per client, while the Go application spawns a goroutine for each client. 

% Maybe write, being benchmarked, instead of tested.
A TCP load generator running in a cloud server is used to send a constant load of network packets to another server running the application being tested. Each application accepts a given number of concurrent client connections, receives its packets (which simulate text messages from the users in a real IM application) and writes the text in the packets to 

The load per concurrent client connection (measured in Mbps) is kept constant throughout all tests and it is delivered to the test subject for a given amount of time. In order to simulate a real-life IM application both implementations read the data being sent to them by the load generator and output it to \textit{stdout}. To not overwhelm the system with filesystem writes and focus primarily in the performance of the concurrency handling mechanisms in a real-life environment, the data being output to stdout is immediately discarded to \textit{/dev/null}. 

Through the experiment the CPU usage is measured and recorded using \textit{top(1)} with a sampling rate of 500ms. The number of active concurrent clients is incremented in each new test, in order to see how that affects the performance of the implementation.

\subsection{Test environment}
2 VMs 1vCPU 2GB RAM, running in the Frankfurt region (low latency) in Vultr cloud
Load generator: tcpkali v1.1.1 running in FreeBSD 13.0-RELEASE-p11
GCC v10.4
Go version v1.18.2